// 버블 정렬의 특징
// 간단한 구현:
// 버블 정렬은 다른 정렬 알고리즘에 비해 구현이 간단하고 이해하기 쉽다.
// 제자리 정렬:
// 추가 메모리를 거의 사용하지 않기 때문에 메모리 효율이 좋다. 입력 배열을 변경하여 정렬을 수행한다.
// 안정적인 정렬:
// 동일한 값을 가진 요소들의 상대적인 순서가 유지되기 때문에 안정적인 정렬 알고리즘이다.
// 최선의 경우 시간 복잡도:
// 이미 정렬된 배열에 대해서는 O(n)의 시간 복잡도로 작동하여 매우 효율적이다.
// 스왑 기반 알고리즘:
// 인접한 두 요소를 비교하여 필요할 때 자리를 바꾸는 방식으로 작동한다.

// 버블 정렬의 단점
// 최악의 시간 복잡도:
// 최악의 경우, 시간 복잡도가 O(n^2)로, 특히 크기가 큰 배열에 대해서는 비효율적이다.
// 많은 데이터 이동:
// 각 요소를 비교하고 자리를 바꾸는 과정이 반복되기 때문에 많은 데이터 이동이 발생한다.
// 부분적으로 정렬되지 않은 배열에 비효율적:
// 데이터가 거의 정렬되지 않은 상태에서는 다른 정렬 알고리즘에 비해 성능이 저하된다.
// 대규모 데이터셋에 비효율적:
// 버블 정렬은 작은 데이터셋에는 적합하지만, 대규모 데이터셋에는 효율적이지 않다.

#include <iostream>
#include <vector>
using namespace std;

void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                // 요소 교환
                swap(arr[j], arr[j + 1]);
            }
        }
        // 현재 배열 상태 출력
        cout << "Step " << i + 1 << ": ";
        for (int x = 0; x < n; ++x) {
            cout << arr[x] << " ";
        }
        cout << endl;
    }
}

int main() {
    vector<int> arr = {64, 34, 25, 12, 22, 11, 90};
    cout << "Initial array: ";
    for (int i = 0; i < arr.size(); ++i) {
        cout << arr[i] << " ";
    }
    cout << endl << "-----------------------" << endl;

    bubbleSort(arr);

    cout << "Sorted array: ";
    for (int i = 0; i < arr.size(); ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}